#pragma once

#include <ntddk.h>
#include <wdf.h>
#include <usb.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <wdfusb.h>
#include <initguid.h>
#include <usbbusif.h>

#define NTSTRSAFE_LIB
#include <ntstrsafe.h>

#include "trace.h"
#include "public.h"

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

//
// The device context performs the same job as a WDM device extension in the driver frameworks
//
typedef struct _DEVICE_CONTEXT {

	WDFUSBDEVICE                    UsbDevice;

	WDFUSBINTERFACE                 UsbInterface;

	WDFUSBPIPE                      BulkReadPipe;

	WDFUSBPIPE                      BulkWritePipe;

	WDFUSBPIPE                      InterruptPipe;

	WDFWAITLOCK                     ResetDeviceWaitLock;

	UCHAR                           CurrentSwitchState;

	WDFQUEUE                        InterruptMsgQueue;

	ULONG                           UsbDeviceTraits;

	//
	// The following fields are used during event logging to 
	// report the events relative to this specific instance 
	// of the device.
	//

	WDFMEMORY                       DeviceNameMemory;
	PCWSTR                          DeviceName;

	WDFMEMORY                       LocationMemory;
	PCWSTR                          Location;

} DEVICE_CONTEXT, *PDEVICE_CONTEXT;

WDF_DECLARE_CONTEXT_TYPE_WITH_NAME(DEVICE_CONTEXT, GetDeviceContext)

//
// This is the context that can be placed per queue and would contain per queue information.
//
typedef struct _QUEUE_CONTEXT {

	ULONG PrivateDeviceData;  // just a placeholder

} QUEUE_CONTEXT, *PQUEUE_CONTEXT;

WDF_DECLARE_CONTEXT_TYPE_WITH_NAME(QUEUE_CONTEXT, GetQueueContext)


typedef
NTSTATUS
(*PFN_IO_GET_ACTIVITY_ID_IRP) (
	_In_     PIRP   Irp,
	_Out_    LPGUID Guid
	);

typedef
NTSTATUS
(*PFN_IO_SET_DEVICE_INTERFACE_PROPERTY_DATA) (
	_In_ PUNICODE_STRING    SymbolicLinkName,
	_In_ CONST DEVPROPKEY   *PropertyKey,
	_In_ LCID               Lcid,
	_In_ ULONG              Flags,
	_In_ DEVPROPTYPE        Type,
	_In_ ULONG              Size,
	_In_opt_ PVOID          Data
	);

//
// Global function pointer set in DriverEntry
// Check for NULL before using
//
extern PFN_IO_GET_ACTIVITY_ID_IRP g_pIoGetActivityIdIrp;

extern PFN_IO_SET_DEVICE_INTERFACE_PROPERTY_DATA g_pIoSetDeviceInterfacePropertyData;

//
// Driver.c func
//

DRIVER_INITIALIZE DriverEntry;
EVT_WDF_OBJECT_CONTEXT_CLEANUP KmdfUsbEvtDriverContextCleanup;


//
// Device.c func
//

EVT_WDF_DRIVER_DEVICE_ADD KmdfUsbEvtDeviceAdd;
EVT_WDF_DEVICE_PREPARE_HARDWARE KmdfUsbEvtDevicePrepareHardware;

_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
SelectInterfaces(
	_In_ WDFDEVICE Device
);

_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
KmdfUsbSetPowerPolicy(
	_In_ WDFDEVICE Device
);

//
// Interrupt.c func
//

_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
KmdfUsbConfigContReaderForInterruptEndPoint(
	_In_ PDEVICE_CONTEXT DeviceContext
);

VOID
KmdfUsbEvtUsbInterruptPipeReadComplete(
	WDFUSBPIPE  Pipe,
	WDFMEMORY   Buffer,
	size_t      NumBytesTransferred,
	WDFCONTEXT  Context
);

BOOLEAN
KmdfUsbEvtUsbInterruptReadersFailed(
	_In_ WDFUSBPIPE Pipe,
	_In_ NTSTATUS Status,
	_In_ USBD_STATUS UsbdStatus
);




NTSTATUS
KmdfUsbQueueInitialize(
	_In_ WDFDEVICE Device
);

EVT_WDF_IO_QUEUE_IO_DEVICE_CONTROL KmdfUsbEvtIoDeviceControl;
EVT_WDF_IO_QUEUE_IO_STOP KmdfUsbEvtIoStop;

//
// Others
//

FORCEINLINE
GUID
RequestToActivityId(
	_In_ WDFREQUEST Request
)
{
	GUID     activity = { 0 };
	NTSTATUS status = STATUS_SUCCESS;

	if (g_pIoGetActivityIdIrp != NULL) {

		//
		// Use activity ID generated by application (or IO manager)
		//    
		status = g_pIoGetActivityIdIrp(WdfRequestWdmGetIrp(Request), &activity);
	}

	if (g_pIoGetActivityIdIrp == NULL || !NT_SUCCESS(status)) {

		//
		// Fall back to using the WDFREQUEST handle as the activity ID
		//
		RtlCopyMemory(&activity, &Request, sizeof(WDFREQUEST));
	}


	return activity;
}

FORCEINLINE
GUID
DeviceToActivityId(
	_In_ WDFDEVICE Device
)
{
	GUID activity = { 0 };
	RtlCopyMemory(&activity, &Device, sizeof(WDFDEVICE));
	return activity;
}

#endif

